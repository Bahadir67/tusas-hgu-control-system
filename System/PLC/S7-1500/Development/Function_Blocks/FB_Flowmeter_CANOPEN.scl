FUNCTION_BLOCK "FB_Flowmeter_CANOPEN"
{ S7_Optimized_Access := 'TRUE' }
VERSION : '1.0'
// =============================================================================
// TUSAŞ HGU Flowmeter CANOPEN Reader V17
// Purpose: 14 flowmeter okuma sistemi (CAN-Ethernet converter üzerinden)
// Protocol: CANOPEN TPDO1 (COB-ID = 0x180 + NodeID)
// NodeID Mapping: 
//   Pump Flow: NodeID 10-16 (COB-ID 0x18A-0x190) - Range: 0-150 L/min
//   Leak Flow: NodeID 17-23 (COB-ID 0x191-0x197) - Range: 1-15 L/min
//
// CAN Frame Structure (8 bytes):
//   Byte 0-3: Float32 Flow Value (L/min)
//   Byte 4: Status (0=No measurement, 1=Normal, 2=Fault)
//   Byte 5-7: Reserved (not used)
//
// TCP Frame Structure (13 bytes total):
//   Byte 0: DLC (Data Length Code = 8)
//   Byte 1-4: COB-ID (32-bit CAN Frame ID, Little Endian)
//   Byte 5-12: CAN Data (8 bytes)
//
// Timing: Each flowmeter sends data every 100ms
// Watchdog: 250ms timeout per flowmeter
// =============================================================================

VAR_INPUT
    Enable : Bool := FALSE;                    // Enable flowmeter reading
    CAN_Ethernet_IP : String[15] := '192.168.100.21'; // CAN-Ethernet converter IP
    TCP_Port : UInt := 40002;                 // TCP port for flowmeter data
    Watchdog_Timeout : Time := T#250ms;       // Watchdog timeout per flowmeter
END_VAR

VAR_OUTPUT
    // Pump flow values (direct mapping to system variables)
    PUMP_1_FLOW_ACTUAL : Real := 0.0;        // Pump 1 flow (L/min, 0-150)
    PUMP_2_FLOW_ACTUAL : Real := 0.0;        // Pump 2 flow (L/min, 0-150)
    PUMP_3_FLOW_ACTUAL : Real := 0.0;        // Pump 3 flow (L/min, 0-150)
    PUMP_4_FLOW_ACTUAL : Real := 0.0;        // Pump 4 flow (L/min, 0-150)
    PUMP_5_FLOW_ACTUAL : Real := 0.0;        // Pump 5 flow (L/min, 0-150)
    PUMP_6_FLOW_ACTUAL : Real := 0.0;        // Pump 6 flow (L/min, 0-150)
    PUMP_7_FLOW_ACTUAL : Real := 0.0;        // Pump 7 flow (L/min, 0-150)
    
    // Pump leak rates (direct mapping to system variables)
    PUMP_1_LEAK_RATE : Real := 0.0;          // Pump 1 leak rate (L/min, 1-15)
    PUMP_2_LEAK_RATE : Real := 0.0;          // Pump 2 leak rate (L/min, 1-15)
    PUMP_3_LEAK_RATE : Real := 0.0;          // Pump 3 leak rate (L/min, 1-15)
    PUMP_4_LEAK_RATE : Real := 0.0;          // Pump 4 leak rate (L/min, 1-15)
    PUMP_5_LEAK_RATE : Real := 0.0;          // Pump 5 leak rate (L/min, 1-15)
    PUMP_6_LEAK_RATE : Real := 0.0;          // Pump 6 leak rate (L/min, 1-15)
    PUMP_7_LEAK_RATE : Real := 0.0;          // Pump 7 leak rate (L/min, 1-15)
    
    // Flowmeter status
    Pump_Flow_Status : Array[1..7] of USInt;  // Status: 0=No measure, 1=Normal, 2=Fault
    Leak_Flow_Status : Array[1..7] of USInt;  // Status: 0=No measure, 1=Normal, 2=Fault
    
    // Communication status
    Communication_OK : Bool := FALSE;          // Overall communication status
    Connection_Established : Bool := FALSE;    // TCP connection status
    Messages_Received : UDInt := 0;           // Total messages received
    
    // Error status
    Watchdog_Errors : Array[1..14] of Bool;   // Individual flowmeter watchdog errors
    Communication_Error : Bool := FALSE;       // Communication error flag
    Error_Code : USInt := 0;                  // Error code (1=Timeout, 2=Invalid frame, 3=Connection)
END_VAR

VAR
    // TCP communication with TRCV_C (TIA Portal V17 compatible)
    TCP_Receive : TRCV_C;                     // TCP receive function block
    Connect_Param : TCON_IP_v4;               // Connection parameters for TRCV_C
    Connection_Request : Bool := FALSE;        // Connection request flag
    Connection_Established : Bool := FALSE;    // Connection status
    Last_Enable : Bool := FALSE;              // Previous enable state
    
    // Receive buffer
    RX_Buffer : Array[0..12] of Byte;         // 13-byte TCP frame buffer
    Frame_Received : Bool := FALSE;           // New frame received flag
    
    // Frame processing
    COB_ID : DWord;                          // Extracted COB-ID
    Node_ID : USInt;                         // Extracted NodeID
    Flow_Value : Real;                       // Extracted flow value
    Status_Byte : USInt;                     // Extracted status
    
    // Watchdog system
    Watchdog_Timer : TON;                    // Main watchdog timer (10ms cycle)
    Watchdog_Counters : Array[1..14] of UInt; // Individual flowmeter counters (x10ms)
    Watchdog_Threshold : UInt;               // Threshold value (250ms / 10ms = 25)
    
    // State machine
    State : USInt := 0;                      // 0=Init, 1=Connecting, 2=Connected, 3=Error
    State_Timer : TON;                       // State transition timer
    Error_Counter : USInt := 0;              // Consecutive error counter
    Reconnect_Timer : TON;                   // Reconnection delay timer
    
    // Statistics
    Frame_Count : UDInt := 0;                // Total frames processed
    Invalid_Frame_Count : UDInt := 0;        // Invalid frames counter
    Timeout_Count : UDInt := 0;              // Timeout events counter
    
    // Initialization
    Init_Complete : Bool := FALSE;           // Initialization complete flag
    
    // Float conversion (for CAN data bytes 0-3)
    Float_Bytes : Array[0..3] of Byte;      // Temporary byte array for float conversion
    Float_DWord : DWord;                     // DWord for float conversion
    
    // Temporary variables for bit operations
    Temp_DWord_0 : DWord;
    Temp_DWord_1 : DWord;
    Temp_DWord_2 : DWord;
    Temp_DWord_3 : DWord;
END_VAR

VAR_TEMP
    i : USInt;                              // Loop counter
    Pump_Index : USInt;                     // Pump array index
    Leak_Index : USInt;                     // Leak array index
END_VAR

BEGIN

// =============================================================================
// INITIALIZATION
// =============================================================================
IF NOT Init_Complete THEN
    // Initialize all outputs
    PUMP_1_FLOW_ACTUAL := 0.0;
    PUMP_2_FLOW_ACTUAL := 0.0;
    PUMP_3_FLOW_ACTUAL := 0.0;
    PUMP_4_FLOW_ACTUAL := 0.0;
    PUMP_5_FLOW_ACTUAL := 0.0;
    PUMP_6_FLOW_ACTUAL := 0.0;
    PUMP_7_FLOW_ACTUAL := 0.0;
    
    PUMP_1_LEAK_RATE := 0.0;
    PUMP_2_LEAK_RATE := 0.0;
    PUMP_3_LEAK_RATE := 0.0;
    PUMP_4_LEAK_RATE := 0.0;
    PUMP_5_LEAK_RATE := 0.0;
    PUMP_6_LEAK_RATE := 0.0;
    PUMP_7_LEAK_RATE := 0.0;
    
    FOR i := 1 TO 7 DO
        Pump_Flow_Status[i] := 0;
        Leak_Flow_Status[i] := 0;
    END_FOR;
    
    FOR i := 1 TO 14 DO
        Watchdog_Errors[i] := FALSE;
        Watchdog_Counters[i] := 0;
    END_FOR;
    
    Communication_OK := FALSE;
    Connection_Established := FALSE;
    Messages_Received := 0;
    Communication_Error := FALSE;
    Error_Code := 0;
    
    // Calculate watchdog threshold (250ms / 10ms = 25)
    Watchdog_Threshold := TIME_TO_UINT(Watchdog_Timeout) / 10;
    
    // Setup connection parameters for TRCV_C (TCON_IP_v4 structure)
    Connect_Param.InterfaceId := 64;
    Connect_Param.ID := 2;
    Connect_Param.ConnectionType := BYTE#17;    // TCP connection (0x11 = 17)
    Connect_Param.ActiveEstablished := TRUE;
    
    Connect_Param.RemoteAddress.ADDR[1] := 192; // IP 192.168.100.21
    Connect_Param.RemoteAddress.ADDR[2] := 168;
    Connect_Param.RemoteAddress.ADDR[3] := 100;
    Connect_Param.RemoteAddress.ADDR[4] := 21;
    Connect_Param.RemotePort := TCP_Port;
    Connect_Param.LocalPort := UINT#0;
    
    State := 0;
    Frame_Count := 0;
    Invalid_Frame_Count := 0;
    Timeout_Count := 0;
    Error_Counter := 0;
    
    Init_Complete := TRUE;
END_IF;

// Enable edge detection
IF Enable AND NOT Last_Enable THEN
    State := 0; // Reset to initialization state
    Error_Counter := 0;
    Communication_Error := FALSE;
    Error_Code := 0;
END_IF;

Last_Enable := Enable;

// =============================================================================
// MAIN STATE MACHINE
// =============================================================================
IF Enable THEN
    
    // =============================================================================
    // WATCHDOG SYSTEM (10ms cycle)
    // =============================================================================
    Watchdog_Timer(IN := NOT Watchdog_Timer.Q, PT := T#10ms);
    
    IF Watchdog_Timer.Q THEN
        // Increment all flowmeter watchdog counters
        FOR i := 1 TO 14 DO
            Watchdog_Counters[i] := Watchdog_Counters[i] + 1;
            
            // Check timeout (250ms = 25 x 10ms)
            IF Watchdog_Counters[i] > Watchdog_Threshold THEN
                Watchdog_Errors[i] := TRUE;
                Timeout_Count := Timeout_Count + 1;
            END_IF;
        END_FOR;
    END_IF;
    
    // =============================================================================
    // TCP COMMUNICATION STATE MACHINE
    // =============================================================================
    CASE State OF
        0: // Initialization
           Connection_Request := TRUE;
           State_Timer(IN := TRUE, PT := T#2s);
           IF State_Timer.Q THEN
               State := 1;
               State_Timer(IN := FALSE, PT := T#2s);
           END_IF;
           
        1: // Connecting and receiving (TRCV_C handles connection automatically)
           TCP_Receive(
               EN_R := Enable AND Connection_Request,
               CONT := Connection_Request,
               LEN := UDINT#13,                 // Fixed 13-byte frames
               CONNECT := Connect_Param,
               DATA := RX_Buffer
           );
           
           Frame_Received := TCP_Receive.DONE;  // New data received
           Connection_Established := NOT TCP_Receive.ERROR;
           
           IF Connection_Established THEN
               State := 2;
               Error_Counter := 0;
           ELSIF TCP_Receive.ERROR THEN
               State := 3;
               Error_Code := 1; // Communication error
               Error_Counter := Error_Counter + 1;
           END_IF;
           
        2: // Connected and receiving (continuous listening)
           TCP_Receive(
               EN_R := TRUE,
               CONT := TRUE,
               LEN := UDINT#13,
               CONNECT := Connect_Param,
               DATA := RX_Buffer
           );
           
           Frame_Received := TCP_Receive.DONE;  // New data received
           Connection_Established := NOT TCP_Receive.ERROR;
           
           IF TCP_Receive.ERROR THEN
               State := 3;
               Error_Code := 1; // Communication error
               Error_Counter := Error_Counter + 1;
           END_IF;
           
        3: // Error state
           Connection_Established := FALSE;
           Communication_Error := TRUE;
           
           // Reconnection logic after 5 seconds
           Reconnect_Timer(IN := TRUE, PT := T#5s);
           IF Reconnect_Timer.Q AND Error_Counter < 10 THEN
               State := 0; // Return to initialization
               Reconnect_Timer(IN := FALSE, PT := T#5s);
           END_IF;
    END_CASE;
    
    // =============================================================================
    // FRAME PROCESSING
    // =============================================================================
    IF Frame_Received THEN
        Frame_Count := Frame_Count + 1;
        
        // Validate frame format (DLC should be 8)
        IF RX_Buffer[0] = 8 THEN
            
            // Extract COB-ID (Little Endian, bytes 1-4)
            Temp_DWord_0 := BYTE_TO_DWORD(RX_Buffer[4]);
            Temp_DWord_1 := BYTE_TO_DWORD(RX_Buffer[3]);
            Temp_DWord_2 := BYTE_TO_DWORD(RX_Buffer[2]);
            Temp_DWord_3 := BYTE_TO_DWORD(RX_Buffer[1]);
            
            COB_ID := Temp_DWord_0 OR
                     SHL(IN := Temp_DWord_1, N := 8) OR
                     SHL(IN := Temp_DWord_2, N := 16) OR
                     SHL(IN := Temp_DWord_3, N := 24);
            
            // Extract NodeID from COB-ID (COB-ID = 0x180 + NodeID)
            IF COB_ID >= 16#180 AND COB_ID <= 16#197 THEN
                Node_ID := DWORD_TO_USINT(COB_ID - 16#180);
                
                // Extract float value (bytes 5-8, Little Endian)
                Float_Bytes[0] := RX_Buffer[8];  // LSB
                Float_Bytes[1] := RX_Buffer[7];
                Float_Bytes[2] := RX_Buffer[6];
                Float_Bytes[3] := RX_Buffer[5];  // MSB
                
                // Convert byte array to DWord then to Real (Manual method)
                Temp_DWord_0 := BYTE_TO_DWORD(Float_Bytes[0]);
                Temp_DWord_1 := BYTE_TO_DWORD(Float_Bytes[1]);
                Temp_DWord_2 := BYTE_TO_DWORD(Float_Bytes[2]);
                Temp_DWord_3 := BYTE_TO_DWORD(Float_Bytes[3]);
                
                Float_DWord := Temp_DWord_0 OR
                              SHL(IN := Temp_DWord_1, N := 8) OR
                              SHL(IN := Temp_DWord_2, N := 16) OR
                              SHL(IN := Temp_DWord_3, N := 24);
                
                Flow_Value := DWORD_TO_REAL(Float_DWord);
                
                // Extract status byte (byte 9)
                Status_Byte := RX_Buffer[9];
                
                // Route data to appropriate variables based on NodeID
                IF Node_ID >= 10 AND Node_ID <= 16 THEN
                    // Pump flow sensors (NodeID 10-16)
                    Pump_Index := Node_ID - 9;  // Convert to pump index 1-7
                    
                    CASE Pump_Index OF
                        1: PUMP_1_FLOW_ACTUAL := Flow_Value;
                        2: PUMP_2_FLOW_ACTUAL := Flow_Value;
                        3: PUMP_3_FLOW_ACTUAL := Flow_Value;
                        4: PUMP_4_FLOW_ACTUAL := Flow_Value;
                        5: PUMP_5_FLOW_ACTUAL := Flow_Value;
                        6: PUMP_6_FLOW_ACTUAL := Flow_Value;
                        7: PUMP_7_FLOW_ACTUAL := Flow_Value;
                    END_CASE;
                    
                    Pump_Flow_Status[Pump_Index] := Status_Byte;
                    
                    // Reset watchdog for this flowmeter
                    Watchdog_Counters[Pump_Index] := 0;
                    Watchdog_Errors[Pump_Index] := FALSE;
                    
                ELSIF Node_ID >= 17 AND Node_ID <= 23 THEN
                    // Leak flow sensors (NodeID 17-23)
                    Leak_Index := Node_ID - 16; // Convert to leak index 1-7
                    
                    CASE Leak_Index OF
                        1: PUMP_1_LEAK_RATE := Flow_Value;
                        2: PUMP_2_LEAK_RATE := Flow_Value;
                        3: PUMP_3_LEAK_RATE := Flow_Value;
                        4: PUMP_4_LEAK_RATE := Flow_Value;
                        5: PUMP_5_LEAK_RATE := Flow_Value;
                        6: PUMP_6_LEAK_RATE := Flow_Value;
                        7: PUMP_7_LEAK_RATE := Flow_Value;
                    END_CASE;
                    
                    Leak_Flow_Status[Leak_Index] := Status_Byte;
                    
                    // Reset watchdog for this flowmeter (offset by 7 for leak sensors)
                    Watchdog_Counters[Leak_Index + 7] := 0;
                    Watchdog_Errors[Leak_Index + 7] := FALSE;
                    
                ELSE
                    // Unknown NodeID
                    Invalid_Frame_Count := Invalid_Frame_Count + 1;
                END_IF;
                
                Messages_Received := Messages_Received + 1;
                
            ELSE
                // Invalid COB-ID
                Invalid_Frame_Count := Invalid_Frame_Count + 1;
            END_IF;
            
        ELSE
            // Invalid DLC
            Invalid_Frame_Count := Invalid_Frame_Count + 1;
        END_IF;
    END_IF;
    
    // =============================================================================
    // OVERALL STATUS CALCULATION
    // =============================================================================
    
    // Check if any watchdog errors exist
    Communication_Error := FALSE;
    FOR i := 1 TO 14 DO
        IF Watchdog_Errors[i] THEN
            Communication_Error := TRUE;
        END_IF;
    END_FOR;
    
    // Overall communication OK if connected and no errors
    Communication_OK := Connection_Established AND NOT Communication_Error;
    
ELSE
    // =============================================================================
    // DISABLED STATE
    // =============================================================================
    
    // Disable TCP communication
    TCP_Receive(
        EN_R := FALSE,
        CONT := FALSE,
        LEN := UDINT#0,
        CONNECT := Connect_Param,
        DATA := RX_Buffer
    );
    Connection_Established := FALSE;
    Communication_OK := FALSE;
    State := 0;
    
    // Stop watchdog timer
    Watchdog_Timer(IN := FALSE, PT := T#10ms);
    
    // Reset all outputs
    PUMP_1_FLOW_ACTUAL := 0.0;
    PUMP_2_FLOW_ACTUAL := 0.0;
    PUMP_3_FLOW_ACTUAL := 0.0;
    PUMP_4_FLOW_ACTUAL := 0.0;
    PUMP_5_FLOW_ACTUAL := 0.0;
    PUMP_6_FLOW_ACTUAL := 0.0;
    PUMP_7_FLOW_ACTUAL := 0.0;
    
    PUMP_1_LEAK_RATE := 0.0;
    PUMP_2_LEAK_RATE := 0.0;
    PUMP_3_LEAK_RATE := 0.0;
    PUMP_4_LEAK_RATE := 0.0;
    PUMP_5_LEAK_RATE := 0.0;
    PUMP_6_LEAK_RATE := 0.0;
    PUMP_7_LEAK_RATE := 0.0;
    
    FOR i := 1 TO 7 DO
        Pump_Flow_Status[i] := 0;
        Leak_Flow_Status[i] := 0;
    END_FOR;
    
    FOR i := 1 TO 14 DO
        Watchdog_Errors[i] := FALSE;
        Watchdog_Counters[i] := 0;
    END_FOR;
    
    Communication_Error := FALSE;
    Error_Code := 0;
    
END_IF;

END_FUNCTION_BLOCK