FUNCTION_BLOCK "FB_Error_Manager"
{ S7_Optimized_Access := 'TRUE' }
VERSION : '1.0'
// =============================================================================
// TUSAÅž HGU System-Wide Error Manager V17
// Purpose: Centralized error and warning collection from all Function Blocks
// Features: Priority-based error management, alarm categorization, system status
// 
// ERROR PRIORITY LEVELS:
// 0 = System OK
// 1 = Info/Status (Blue)    - System information
// 2 = Warning (Yellow)      - Non-critical warnings
// 3 = Error (Orange)        - Operational errors
// 4 = Critical (Red)        - Safety critical errors
// 5 = Emergency (Flashing Red) - Emergency stop required
//
// ERROR CATEGORIES:
// A. Safety Critical (Priority 4-5)
//    - Emergency stops, protection failures, critical communication timeouts
// B. Communication (Priority 3-4)
//    - TCP communication failures, watchdog timeouts
// C. Hardware Faults (Priority 3)
//    - Motor thermal faults, sensor errors, drive faults
// D. Process Warnings (Priority 2)
//    - Filter warnings, pressure deviations, flow limits
// E. System Status (Priority 1)
//    - Operational status, maintenance due, statistics
// =============================================================================

VAR_INPUT
    Enable : Bool := FALSE;                    // Enable error manager
END_VAR

VAR_OUTPUT
    // Basic status
    Emergency_Stop_Active : Bool := FALSE;     // Any emergency stop active
    Motor_Thermal_Error : Bool := FALSE;       // Any motor thermal error
    
    // Analog sensor errors (from FB_Analog_Input_Processing)
    Analog_Sensor_Error : Bool := FALSE;       // Any analog sensor error active
    Temperature_Sensor_Error : Bool := FALSE;  // Temperature sensors (1, 18, 19)
    Level_Sensor_Error : Bool := FALSE;        // Level sensor (2) - ContinuousLevelSensor
    Aqua_Sensor_Error : Bool := FALSE;         // Aqua sensor (3) - AquaSensor
    Pump_Pressure_Error : Bool := FALSE;       // Pump pressure sensors (4-10)
    HSM_Pressure_Error : Bool := FALSE;        // HSM pressure sensors (11-17)
    
    // Control system errors (from FB_Dual_Controller instances)
    Dual_Controller_Error : Bool := FALSE;     // Any dual controller error active
    Flow_Controller_Error : Bool := FALSE;     // Flow controller errors (11-14)
    Pressure_Controller_Error : Bool := FALSE; // Pressure controller errors (21-24)
    
    // Communication system errors (from FB_Flowmeter_CANOPEN)
    Flowmeter_Communication_Error : Bool := FALSE; // Flowmeter communication error active
    Flowmeter_Watchdog_Error : Bool := FALSE;   // Any flowmeter watchdog timeout
    
    // Drive system errors (from FB_G120C_Drive instances)
    G120C_Motor_Fault : Bool := FALSE;         // Any G120C motor fault active
    G120C_Communication_Error : Bool := FALSE;  // Any G120C communication error
    G120C_Safety_Error : Bool := FALSE;        // Any G120C safety error
    G120C_Parameter_Error : Bool := FALSE;     // Any G120C parameter error
    
    // Pressure safety valve system errors (from FB_Pressure_Safety_Valves)
    Valve_Watchdog_Error : Bool := FALSE;      // CRITICAL: 250ms valve watchdog timeout
    Valve_Emergency_Stop_Required : Bool := FALSE; // CRITICAL: Emergency stop required by valve controller
    Valve_Communication_Error : Bool := FALSE; // Valve controller communication error
    
    // Digital input and filter system errors (from FB_Digital_Input_Processing)
    Digital_Input_Error : Bool := FALSE;       // Any digital input error active
    Filter_Error : Bool := FALSE;              // Any motor filter error active (1-7)
    Tank_Level_Error : Bool := FALSE;          // Tank level error (low level)
    Chiller_Flow_Error : Bool := FALSE;        // Chiller water flow error
    
    // Motor selection system errors (from FB_Motor_Selection)
    Motor_Selection_Error : Bool := FALSE;     // Motor selection algorithm error
    Insufficient_Motor_Capacity : Bool := FALSE; // Insufficient motor flow capacity
    Insufficient_Available_Motors : Bool := FALSE; // Not enough motors available
    
    // MCC (Motor Control Center) DO command-feedback errors (from FB_Safety_Status_Manager)
    MCC_Error_Status : Bool := FALSE;          // Any MCC command-feedback error active
    Particle_Contactor_Error : Bool := FALSE;  // Particle contactor mismatch error
    Circ_Contactor_Error : Bool := FALSE;      // Circulation contactor mismatch error
    Circ_SoftStarter_Error : Bool := FALSE;    // Circulation soft starter mismatch error
    CoilTube_Contactor_Error : Bool := FALSE;  // CoilTube contactor mismatch error
    CoilTube_SoftStarter_Error : Bool := FALSE; // CoilTube soft starter mismatch error
    
    // System status
    System_Error_Active : Bool := FALSE;       // Any system error active
    Total_Active_Errors : USInt := 0;          // Total number of active errors
    
    // Legacy compatibility outputs (for existing code that references these)
    Emergency_Stop_Required : Bool := FALSE;   // Emergency stop required (alias for Emergency_Stop_Active)
    Master_Error_Code : USInt := 0;            // Master error code (highest priority active error)
    Current_Error_Priority : USInt := 0;       // Current error priority level (0-5)
END_VAR

VAR
    // Analog sensor error processing (simplified - read from DB)
    Analog_Error_Word : Word := 0;             // Copy of ANALOG_ERROR_WORD from DB
    Current_Analog_Error_Code : USInt := 0;    // Copy of ANALOG_ERROR_CODE from DB
    
    // Dual controller error processing (read from System Coordinator)
    Current_Dual_Controller_Error_Code : USInt := 0;    // Current dual controller error code
    
    // Flowmeter error processing (read from FB_Flowmeter_CANOPEN instance)
    Current_Flowmeter_Error_Code : USInt := 0;          // Current flowmeter error code
    Flowmeter_Watchdog_Count : USInt := 0;              // Number of active watchdog errors
    
    // G120C Drive error processing (read from 6 motor instances)
    Current_G120C_Error_Code : USInt := 0;              // Current G120C error code (highest priority)
    Current_G120C_Warning_Code : USInt := 0;            // Current G120C warning code
    G120C_Fault_Count : USInt := 0;                     // Number of motors in fault
    
    // Pressure safety valve error processing (read from FB_Pressure_Safety_Valves instance)
    Current_Valve_Error_Code : USInt := 0;              // Current valve controller error code
    Valve_Controller_OK : Bool := FALSE;                // Valve controller communication status
    
    // Digital input and filter error processing (read from FB_Digital_Input_Processing instance)
    Current_Filter_Error_Code : USInt := 0;             // Current filter error code
    Total_Filter_Error_Count : USInt := 0;              // Total active filter errors
    
    // Motor selection error processing (read from FB_Motor_Selection instances)
    Current_Motor_Selection_Error_Code : USInt := 0;    // Current motor selection error code
    Motor_Selection_Error_Count : USInt := 0;           // Number of motor selection errors
    
    // MCC (Motor Control Center) error processing (read from FB_Safety_Status_Manager instance)
    Current_MCC_Error_Code : USInt := 0;                // Current MCC error code (1-5)
    Total_MCC_Error_Count : USInt := 0;                 // Total number of active MCC errors
    
    // Processing control
    Processing_Timer : TON;
    Init_Complete : Bool := FALSE;
    
    i : USInt; // Loop counter
END_VAR

VAR_TEMP
    Temp_DWord : DWord;
    Temp_Bool : Bool;
END_VAR

BEGIN

// =============================================================================
// INITIALIZATION
// =============================================================================
IF NOT Init_Complete THEN
    Emergency_Stop_Active := FALSE;
    Motor_Thermal_Error := FALSE;
    Analog_Sensor_Error := FALSE;
    System_Error_Active := FALSE;
    Total_Active_Errors := 0;
    
    // Legacy compatibility outputs
    Emergency_Stop_Required := FALSE;
    Master_Error_Code := 0;
    Current_Error_Priority := 0;
    
    // Flowmeter error initialization
    Flowmeter_Communication_Error := FALSE;
    Flowmeter_Watchdog_Error := FALSE;
    
    // G120C Drive error initialization
    G120C_Motor_Fault := FALSE;
    G120C_Communication_Error := FALSE;
    G120C_Safety_Error := FALSE;
    G120C_Parameter_Error := FALSE;
    
    // MCC error initialization
    MCC_Error_Status := FALSE;
    Particle_Contactor_Error := FALSE;
    Circ_Contactor_Error := FALSE;
    Circ_SoftStarter_Error := FALSE;
    CoilTube_Contactor_Error := FALSE;
    CoilTube_SoftStarter_Error := FALSE;
    
    Processing_Timer(IN := FALSE, PT := T#100ms);
    Init_Complete := TRUE;
END_IF;

// =============================================================================
// MAIN PROCESSING LOGIC
// =============================================================================
IF Enable THEN
    
    // Process every 100ms
    Processing_Timer(IN := TRUE, PT := T#100ms);
    
    IF Processing_Timer.Q THEN
        
        // =============================================================================
        // READ ERROR INPUTS FROM ALL FBs (via DB or direct calls)
        // =============================================================================
        
        // =============================================================================
        // READ SAFETY AND MOTOR ERRORS (processed by FB_Safety_Motor_Error_Processing)
        // =============================================================================
        
        // Read safety and motor status from DB (processed by FB_Safety_Motor_Error_Processing)
        Emergency_Stop_Active := "DB_HGU_Execution_V17".CRITICAL_SAFETY_ERROR;
        Motor_Thermal_Error := "DB_HGU_Execution_V17".ANY_MOTOR_ERROR;
        
        // =============================================================================
        // ANALOG SENSOR ERROR PROCESSING (simplified - read from DB only)
        // =============================================================================
        
        // Read analog sensor status directly from DB (processed by FB_Analog_Input_Processing)
        Analog_Sensor_Error := "DB_HGU_Execution_V17".ANALOG_SENSOR_ERROR;
        Current_Analog_Error_Code := "DB_HGU_Execution_V17".ANALOG_ERROR_CODE;
        Analog_Error_Word := "DB_HGU_Execution_V17".ANALOG_ERROR_WORD;
        
        // Decode error categories from bit patterns (for output categorization)
        Temperature_Sensor_Error := FALSE;
        Level_Sensor_Error := FALSE;
        Aqua_Sensor_Error := FALSE;
        Pump_Pressure_Error := FALSE;
        HSM_Pressure_Error := FALSE;
        
        IF Analog_Sensor_Error THEN
            // Categorize based on error code for simplified output signals
            CASE Current_Analog_Error_Code OF
                1, 18, 19:  // Temperature sensors (system temp, chiller inlet, chiller outlet)
                    Temperature_Sensor_Error := TRUE;
                    
                2:          // Continuous level sensor
                    Level_Sensor_Error := TRUE;
                    
                3:          // Aqua sensor
                    Aqua_Sensor_Error := TRUE;
                    
                4, 5, 6, 7, 8, 9, 10:  // Pump pressure sensors (1-6, CoilTube)
                    Pump_Pressure_Error := TRUE;
                    
                11, 12, 13, 14, 15, 16, 17:  // HSM pressure sensors (1-7)
                    HSM_Pressure_Error := TRUE;
            END_CASE;
        END_IF;
        
        // =============================================================================
        // DUAL CONTROLLER ERROR PROCESSING (via System Coordinator)
        // =============================================================================
        
        // Read dual controller errors from System Coordinator instances
        // Assuming multiple dual controller instances for different motors
        Dual_Controller_Error := FALSE;
        Flow_Controller_Error := FALSE;
        Pressure_Controller_Error := FALSE;
        Current_Dual_Controller_Error_Code := 0;
        
        // Check all dual controller instances via System Coordinator
        // Motor 1-6 dual controllers (example pattern)
        FOR i := 1 TO 6 DO
            CASE i OF
                1: IF "DB_System_Coordinator_Instance".Dual_Controller_1.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_1.Error_Code;
                   END_IF;
                2: IF "DB_System_Coordinator_Instance".Dual_Controller_2.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_2.Error_Code;
                   END_IF;
                3: IF "DB_System_Coordinator_Instance".Dual_Controller_3.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_3.Error_Code;
                   END_IF;
                4: IF "DB_System_Coordinator_Instance".Dual_Controller_4.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_4.Error_Code;
                   END_IF;
                5: IF "DB_System_Coordinator_Instance".Dual_Controller_5.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_5.Error_Code;
                   END_IF;
                6: IF "DB_System_Coordinator_Instance".Dual_Controller_6.Error_Status THEN
                       Dual_Controller_Error := TRUE;
                       Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_6.Error_Code;
                   END_IF;
            END_CASE;
        END_FOR;
        
        // Categorize dual controller errors
        IF Dual_Controller_Error THEN
            IF Current_Dual_Controller_Error_Code >= 11 AND Current_Dual_Controller_Error_Code <= 14 THEN
                Flow_Controller_Error := TRUE;          // Flow controller errors (11-14)
            ELSIF Current_Dual_Controller_Error_Code >= 21 AND Current_Dual_Controller_Error_Code <= 24 THEN
                Pressure_Controller_Error := TRUE;      // Pressure controller errors (21-24)
            END_IF;
        END_IF;
        
        // =============================================================================
        // FLOWMETER COMMUNICATION ERROR PROCESSING (via FB_Flowmeter_CANOPEN instance)
        // =============================================================================
        
        // Read flowmeter communication status from DB (processed by FB_Flowmeter_CANOPEN)
        // Use CAN communication status variables in DB
        Flowmeter_Communication_Error := "DB_HGU_Execution_V17".CAN_SYSTEM_ERROR;
        
        // Map CAN system error to flowmeter error code
        IF Flowmeter_Communication_Error THEN
            Current_Flowmeter_Error_Code := 1; // Generic CAN communication error
        ELSE
            Current_Flowmeter_Error_Code := 0; // No error
        END_IF;
        
        // Check CAN TCP connection status for watchdog error simulation
        // If CAN not connected or no active devices, consider as watchdog error
        IF NOT "DB_HGU_Execution_V17".CAN_TCP_CONNECTED OR "DB_HGU_Execution_V17".CAN_ACTIVE_DEVICE_COUNT < 14 THEN
            Flowmeter_Watchdog_Error := TRUE;
            Flowmeter_Watchdog_Count := 14 - "DB_HGU_Execution_V17".CAN_ACTIVE_DEVICE_COUNT; // Missing device count
        ELSE
            Flowmeter_Watchdog_Error := FALSE;
            Flowmeter_Watchdog_Count := 0;
        END_IF;
        
        // =============================================================================
        // G120C DRIVE ERROR PROCESSING (via 6 motor instances in DB)
        // =============================================================================
        
        // Read G120C drive status from DB variables (processed by FB_G120C_Drive instances)
        // Check all 6 motors for faults and errors
        G120C_Motor_Fault := FALSE;
        G120C_Communication_Error := FALSE;
        G120C_Safety_Error := FALSE;
        G120C_Parameter_Error := FALSE;
        G120C_Fault_Count := 0;
        Current_G120C_Error_Code := 0;
        Current_G120C_Warning_Code := 0;
        
        // Motor 1 status check
        IF "DB_HGU_Execution_V17".MOTOR_1_STATUS = 3 THEN // Status 3 = Error
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_1_ERROR_CODE;
            END_IF;
        END_IF;
        
        // Motor 2 status check
        IF "DB_HGU_Execution_V17".MOTOR_2_STATUS = 3 THEN
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_2_ERROR_CODE;
            END_IF;
        END_IF;
        
        // Motor 3 status check
        IF "DB_HGU_Execution_V17".MOTOR_3_STATUS = 3 THEN
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_3_ERROR_CODE;
            END_IF;
        END_IF;
        
        // Motor 4 status check
        IF "DB_HGU_Execution_V17".MOTOR_4_STATUS = 3 THEN
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_4_ERROR_CODE;
            END_IF;
        END_IF;
        
        // Motor 5 status check
        IF "DB_HGU_Execution_V17".MOTOR_5_STATUS = 3 THEN
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_5_ERROR_CODE;
            END_IF;
        END_IF;
        
        // Motor 6 status check
        IF "DB_HGU_Execution_V17".MOTOR_6_STATUS = 3 THEN
            G120C_Motor_Fault := TRUE;
            G120C_Fault_Count := G120C_Fault_Count + 1;
            IF Current_G120C_Error_Code = 0 THEN
                Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_6_ERROR_CODE;
            END_IF;
        END_IF;
        
        // TODO: Communication, Safety, and Parameter errors need direct access to G120C instances
        // These require instance calls like "Motor_1_G120C_Instance".Communication_Error
        // For now, framework is in place but logic needs G120C instance integration
        
        // Framework for future G120C Communication Error detection:
        // IF "Motor_1_G120C_Instance".Communication_Error OR "Motor_2_G120C_Instance".Communication_Error... THEN
        //     G120C_Communication_Error := TRUE;
        // END_IF;
        
        // Framework for future G120C Safety Error detection:
        // IF "Motor_1_G120C_Instance".Safety_Error OR "Motor_2_G120C_Instance".Safety_Error... THEN
        //     G120C_Safety_Error := TRUE;
        // END_IF;
        
        // Framework for future G120C Parameter Error detection:
        // IF "Motor_1_G120C_Instance".Parameter_Error OR "Motor_2_G120C_Instance".Parameter_Error... THEN
        //     G120C_Parameter_Error := TRUE;
        // END_IF;
        
        // =============================================================================
        // PRESSURE SAFETY VALVE ERROR PROCESSING (via FB_Pressure_Safety_Valves instance)
        // =============================================================================
        
        // Read valve controller status from instance (via System Coordinator or direct instance call)
        // TODO: This requires access to FB_Pressure_Safety_Valves instance
        // For now, using DB variables if available, otherwise framework for future instance integration
        
        // Framework for future Valve Controller Error detection:
        // IF "Valve_Controller_Instance".Watchdog_Error THEN
        //     Valve_Watchdog_Error := TRUE;
        //     Current_Valve_Error_Code := "Valve_Controller_Instance".Error_Code;
        // END_IF;
        // IF "Valve_Controller_Instance".Emergency_Stop_Required THEN
        //     Valve_Emergency_Stop_Required := TRUE;
        // END_IF;
        // IF NOT "Valve_Controller_Instance".Communication_OK THEN
        //     Valve_Communication_Error := TRUE;
        // END_IF;
        
        // For now, reset valve errors (will be implemented when instance access is available)
        Valve_Watchdog_Error := FALSE;
        Valve_Emergency_Stop_Required := FALSE;
        Valve_Communication_Error := FALSE;
        Current_Valve_Error_Code := 0;
        Valve_Controller_OK := TRUE;
        
        // =============================================================================
        // DIGITAL INPUT AND FILTER ERROR PROCESSING (via FB_Digital_Input_Processing instance)
        // =============================================================================
        
        // Read filter and digital input status from instance (via System Coordinator or direct instance call)
        // TODO: This requires access to FB_Digital_Input_Processing instance
        // For now, using DB variables if available, otherwise framework for future instance integration
        
        // Framework for future Filter Error detection:
        // IF "Digital_Input_Instance".Error_Status THEN
        //     Digital_Input_Error := TRUE;
        //     Current_Filter_Error_Code := "Digital_Input_Instance".Error_Code;
        //     Total_Filter_Error_Count := "Digital_Input_Instance".Total_Filter_Errors;
        // END_IF;
        
        // Categorize filter errors based on error code
        // IF Current_Filter_Error_Code >= 1 AND Current_Filter_Error_Code <= 7 THEN
        //     Filter_Error := TRUE; // Motor filter errors (1-7)
        // ELSIF Current_Filter_Error_Code = 10 THEN
        //     Tank_Level_Error := TRUE; // Tank level error
        // ELSIF Current_Filter_Error_Code = 11 THEN
        //     Chiller_Flow_Error := TRUE; // Chiller flow error
        // END_IF;
        
        // For now, reset filter errors (will be implemented when instance access is available)
        Digital_Input_Error := FALSE;
        Filter_Error := FALSE;
        Tank_Level_Error := FALSE;
        Chiller_Flow_Error := FALSE;
        Current_Filter_Error_Code := 0;
        Total_Filter_Error_Count := 0;
        
        // =============================================================================
        // MOTOR SELECTION ERROR PROCESSING (via FB_Motor_Selection instances)
        // =============================================================================
        
        // Read motor selection errors from instances (via System Coordinator or direct instance call)
        // TODO: This requires access to FB_Motor_Selection instances
        // For now, using DB variables if available, otherwise framework for future instance integration
        
        // Framework for future Motor Selection Error detection:
        // Motor_Selection_Error := FALSE;
        // Motor_Selection_Error_Count := 0;
        // Current_Motor_Selection_Error_Code := 0;
        
        // FOR i := 1 TO 6 DO  // Check all 6 motor selection instances
        //     CASE i OF
        //         1: IF "Motor_Selection_Instance_1".Error_Status THEN
        //                Motor_Selection_Error := TRUE;
        //                Current_Motor_Selection_Error_Code := "Motor_Selection_Instance_1".Error_Code;
        //                Motor_Selection_Error_Count := Motor_Selection_Error_Count + 1;
        //                
        //                // Categorize error types
        //                IF "Motor_Selection_Instance_1".Error_Code = 1 THEN
        //                    Insufficient_Motor_Capacity := TRUE;
        //                ELSIF "Motor_Selection_Instance_1".Error_Code = 2 THEN
        //                    Insufficient_Available_Motors := TRUE;
        //                END_IF;
        //            END_IF;
        //     END_CASE;
        // END_FOR;
        
        // For now, reset motor selection errors (will be implemented when instance access is available)
        Motor_Selection_Error := FALSE;
        Insufficient_Motor_Capacity := FALSE;
        Insufficient_Available_Motors := FALSE;
        Current_Motor_Selection_Error_Code := 0;
        Motor_Selection_Error_Count := 0;
        
        // =============================================================================
        // MCC (MOTOR CONTROL CENTER) ERROR PROCESSING (via FB_Safety_Status_Manager instance)
        // =============================================================================
        
        // Read MCC errors from Safety Status Manager instance (via System Coordinator or direct instance call)
        // TODO: This requires access to FB_Safety_Status_Manager instance
        // For now, using DB variables if available, otherwise framework for future instance integration
        
        // Framework for future MCC Error detection:
        // IF "Safety_Status_Manager_Instance".MCC_Error_Status THEN
        //     MCC_Error_Status := TRUE;
        //     Current_MCC_Error_Code := "Safety_Status_Manager_Instance".MCC_Error_Code;
        //     Total_MCC_Error_Count := "Safety_Status_Manager_Instance".Total_MCC_Errors;
        //     
        //     // Individual DO command-feedback errors
        //     Particle_Contactor_Error := "Safety_Status_Manager_Instance".Particle_Contactor_Error;
        //     Circ_Contactor_Error := "Safety_Status_Manager_Instance".Circ_Contactor_Error;
        //     Circ_SoftStarter_Error := "Safety_Status_Manager_Instance".Circ_SoftStarter_Error;
        //     CoilTube_Contactor_Error := "Safety_Status_Manager_Instance".CoilTube_Contactor_Error;
        //     CoilTube_SoftStarter_Error := "Safety_Status_Manager_Instance".CoilTube_SoftStarter_Error;
        // ELSE
        //     MCC_Error_Status := FALSE;
        //     Current_MCC_Error_Code := 0;
        //     Total_MCC_Error_Count := 0;
        //     
        //     Particle_Contactor_Error := FALSE;
        //     Circ_Contactor_Error := FALSE;
        //     Circ_SoftStarter_Error := FALSE;
        //     CoilTube_Contactor_Error := FALSE;
        //     CoilTube_SoftStarter_Error := FALSE;
        // END_IF;
        
        // For now, reset MCC errors (will be implemented when instance access is available)
        MCC_Error_Status := FALSE;
        Particle_Contactor_Error := FALSE;
        Circ_Contactor_Error := FALSE;
        Circ_SoftStarter_Error := FALSE;
        CoilTube_Contactor_Error := FALSE;
        CoilTube_SoftStarter_Error := FALSE;
        Current_MCC_Error_Code := 0;
        Total_MCC_Error_Count := 0;
        
        // =============================================================================
        // SIMPLE PROCESSING - Emergency Stops, Motor Thermal, Analog, Control, Communication, Drive, Valve, and Filter Errors
        // =============================================================================
        
        // Emergency Stop and Motor Thermal status are already read from DB above
        // (processed by FB_Safety_Motor_Error_Processing)
        
        // Calculate total active errors (including G120C drive errors, valve errors, and filter errors)
        Total_Active_Errors := 0;
        IF Emergency_Stop_Active THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Motor_Thermal_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Temperature_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Level_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Aqua_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Pump_Pressure_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF HSM_Pressure_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Flow_Controller_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Pressure_Controller_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Flowmeter_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Flowmeter_Watchdog_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Motor_Fault THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Safety_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Parameter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Watchdog_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Emergency_Stop_Required THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Filter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Tank_Level_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Chiller_Flow_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Motor_Selection_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Insufficient_Motor_Capacity THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Insufficient_Available_Motors THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Particle_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Circ_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Circ_SoftStarter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF CoilTube_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF CoilTube_SoftStarter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        
        // Overall system error status (including G120C drive errors, valve errors, filter errors, motor selection errors, and MCC errors)
        System_Error_Active := Emergency_Stop_Active OR Motor_Thermal_Error OR Analog_Sensor_Error OR Dual_Controller_Error OR Flowmeter_Communication_Error OR Flowmeter_Watchdog_Error OR G120C_Motor_Fault OR G120C_Communication_Error OR G120C_Safety_Error OR G120C_Parameter_Error OR Valve_Watchdog_Error OR Valve_Emergency_Stop_Required OR Valve_Communication_Error OR Digital_Input_Error OR Filter_Error OR Tank_Level_Error OR Chiller_Flow_Error OR Motor_Selection_Error OR Insufficient_Motor_Capacity OR Insufficient_Available_Motors OR MCC_Error_Status;
        
        // =============================================================================
        // LEGACY COMPATIBILITY OUTPUTS
        // =============================================================================
        
        // Emergency_Stop_Required is alias for Emergency_Stop_Active
        Emergency_Stop_Required := Emergency_Stop_Active;
        
        // Master_Error_Code: Priority-based error code assignment
        Master_Error_Code := 0;
        Current_Error_Priority := 0;
        
        // Priority 5: Emergency Stop and Valve Critical Errors (Critical)
        IF Emergency_Stop_Active THEN
            Master_Error_Code := 100; // Emergency stop base code
            Current_Error_Priority := 5;
        
        // Priority 5: Valve Controller Critical Errors (Emergency)
        ELSIF Valve_Emergency_Stop_Required OR Valve_Watchdog_Error THEN
            IF Valve_Emergency_Stop_Required THEN
                Master_Error_Code := 600; // Valve emergency stop required base code
            ELSE
                Master_Error_Code := 610 + Current_Valve_Error_Code; // Valve watchdog error base + error code (611-619)
            END_IF;
            Current_Error_Priority := 5;
        
        // Priority 4: Motor Thermal Error (High)
        ELSIF Motor_Thermal_Error THEN
            Master_Error_Code := 200; // Motor thermal base code
            Current_Error_Priority := 4;
        
        // Priority 3: G120C Drive Error (Medium-High)
        ELSIF G120C_Motor_Fault OR G120C_Safety_Error THEN
            IF G120C_Safety_Error THEN
                Master_Error_Code := 500; // G120C safety error base code
            ELSE
                Master_Error_Code := 400 + Current_G120C_Error_Code; // G120C motor fault base + error code (401-499)
            END_IF;
            Current_Error_Priority := 3;
        
        // Priority 3: Dual Controller Error (Medium-High)
        ELSIF Dual_Controller_Error THEN
            Master_Error_Code := Current_Dual_Controller_Error_Code; // Use actual error code (11-14, 21-24)
            Current_Error_Priority := 3;
        
        // Priority 2: G120C Communication/Parameter Error (Medium)
        ELSIF G120C_Communication_Error OR G120C_Parameter_Error THEN
            IF G120C_Parameter_Error THEN
                Master_Error_Code := 550; // G120C parameter error base code
            ELSE
                Master_Error_Code := 520; // G120C communication error base code
            END_IF;
            Current_Error_Priority := 2;
        
        // Priority 2: Valve Communication Error (Medium)
        ELSIF Valve_Communication_Error THEN
            Master_Error_Code := 620 + Current_Valve_Error_Code; // Valve communication error base + error code (621-629)
            Current_Error_Priority := 2;
        
        // Priority 2: Flowmeter Communication Error (Medium)
        ELSIF Flowmeter_Communication_Error OR Flowmeter_Watchdog_Error THEN
            IF Flowmeter_Watchdog_Error THEN
                Master_Error_Code := 300 + Flowmeter_Watchdog_Count; // Watchdog error base + count (301-314)
            ELSE
                Master_Error_Code := 300 + Current_Flowmeter_Error_Code; // Communication error base + error code (301-303)
            END_IF;
            Current_Error_Priority := 2;
        
        // Priority 2: Tank Level Error (Medium)
        ELSIF Tank_Level_Error THEN
            Master_Error_Code := 700; // Tank level error base code
            Current_Error_Priority := 2;
        
        // Priority 2: MCC Command-Feedback Error (Medium)
        ELSIF MCC_Error_Status THEN
            Master_Error_Code := 740 + Current_MCC_Error_Code; // MCC error base + error code (741-745)
            Current_Error_Priority := 2;
        
        // Priority 1: Filter, Chiller, and Motor Selection Error (Low)
        ELSIF Filter_Error OR Chiller_Flow_Error OR Motor_Selection_Error OR Insufficient_Motor_Capacity OR Insufficient_Available_Motors THEN
            IF Filter_Error THEN
                Master_Error_Code := 710 + Current_Filter_Error_Code; // Filter error base + error code (711-717)
            ELSIF Chiller_Flow_Error THEN
                Master_Error_Code := 720; // Chiller flow error base code
            ELSIF Insufficient_Motor_Capacity THEN
                Master_Error_Code := 730; // Insufficient motor capacity error
            ELSIF Insufficient_Available_Motors THEN
                Master_Error_Code := 731; // Insufficient available motors error
            ELSE
                Master_Error_Code := 732 + Current_Motor_Selection_Error_Code; // Motor selection error base + error code (733-739)
            END_IF;
            Current_Error_Priority := 1;
        
        // Priority 1: Analog Sensor Error (Low)
        ELSIF Analog_Sensor_Error THEN
            Master_Error_Code := Current_Analog_Error_Code; // Use actual sensor error code (1-19)
            Current_Error_Priority := 1;
        
        // Priority 0: System OK
        ELSE
            Master_Error_Code := 0;
            Current_Error_Priority := 0;
        END_IF;
        
        // Update DB variables (analog variables are handled by FB_Analog_Input_Processing)
        "DB_HGU_Execution_V17".CRITICAL_SAFETY_ERROR := Emergency_Stop_Active;
        "DB_HGU_Execution_V17".ANY_MOTOR_ERROR := Motor_Thermal_Error;
        "DB_HGU_Execution_V17".SYSTEM_ERROR_ACTIVE := System_Error_Active;
        "DB_HGU_Execution_V17".DUAL_CONTROLLER_ERROR := Dual_Controller_Error;
        "DB_HGU_Execution_V17".FLOW_CONTROLLER_ERROR := Flow_Controller_Error;
        "DB_HGU_Execution_V17".PRESSURE_CONTROLLER_ERROR := Pressure_Controller_Error;
        "DB_HGU_Execution_V17".FLOWMETER_COMMUNICATION_ERROR := Flowmeter_Communication_Error;
        "DB_HGU_Execution_V17".FLOWMETER_WATCHDOG_ERROR := Flowmeter_Watchdog_Error;
        "DB_HGU_Execution_V17".G120C_MOTOR_FAULT := G120C_Motor_Fault;
        "DB_HGU_Execution_V17".G120C_COMMUNICATION_ERROR := G120C_Communication_Error;
        "DB_HGU_Execution_V17".G120C_SAFETY_ERROR := G120C_Safety_Error;
        "DB_HGU_Execution_V17".G120C_PARAMETER_ERROR := G120C_Parameter_Error;
        "DB_HGU_Execution_V17".VALVE_WATCHDOG_ERROR := Valve_Watchdog_Error;
        "DB_HGU_Execution_V17".VALVE_EMERGENCY_STOP_REQUIRED := Valve_Emergency_Stop_Required;
        "DB_HGU_Execution_V17".VALVE_COMMUNICATION_ERROR := Valve_Communication_Error;
        "DB_HGU_Execution_V17".DIGITAL_INPUT_ERROR := Digital_Input_Error;
        "DB_HGU_Execution_V17".FILTER_ERROR := Filter_Error;
        "DB_HGU_Execution_V17".TANK_LEVEL_ERROR := Tank_Level_Error;
        "DB_HGU_Execution_V17".CHILLER_FLOW_ERROR := Chiller_Flow_Error;
        "DB_HGU_Execution_V17".MOTOR_SELECTION_ERROR := Motor_Selection_Error;
        "DB_HGU_Execution_V17".INSUFFICIENT_MOTOR_CAPACITY := Insufficient_Motor_Capacity;
        "DB_HGU_Execution_V17".INSUFFICIENT_AVAILABLE_MOTORS := Insufficient_Available_Motors;
        "DB_HGU_Execution_V17".MCC_ERROR_STATUS := MCC_Error_Status;
        "DB_HGU_Execution_V17".PARTICLE_CONTACTOR_ERROR := Particle_Contactor_Error;
        "DB_HGU_Execution_V17".CIRC_CONTACTOR_ERROR := Circ_Contactor_Error;
        "DB_HGU_Execution_V17".CIRC_SOFTSTARTER_ERROR := Circ_SoftStarter_Error;
        "DB_HGU_Execution_V17".COILTUBE_CONTACTOR_ERROR := CoilTube_Contactor_Error;
        "DB_HGU_Execution_V17".COILTUBE_SOFTSTARTER_ERROR := CoilTube_SoftStarter_Error;
        
        Processing_Timer(IN := FALSE, PT := T#100ms);
    END_IF;
    
ELSE
    // =============================================================================
    // DISABLED STATE
    // =============================================================================
    Emergency_Stop_Active := FALSE;
    Motor_Thermal_Error := FALSE;
    Analog_Sensor_Error := FALSE;
    Temperature_Sensor_Error := FALSE;
    Level_Sensor_Error := FALSE;
    Aqua_Sensor_Error := FALSE;
    Pump_Pressure_Error := FALSE;
    HSM_Pressure_Error := FALSE;
    Dual_Controller_Error := FALSE;
    Flow_Controller_Error := FALSE;
    Pressure_Controller_Error := FALSE;
    Flowmeter_Communication_Error := FALSE;
    Flowmeter_Watchdog_Error := FALSE;
    G120C_Motor_Fault := FALSE;
    G120C_Communication_Error := FALSE;
    G120C_Safety_Error := FALSE;
    G120C_Parameter_Error := FALSE;
    Valve_Watchdog_Error := FALSE;
    Valve_Emergency_Stop_Required := FALSE;
    Valve_Communication_Error := FALSE;
    Digital_Input_Error := FALSE;
    Filter_Error := FALSE;
    Tank_Level_Error := FALSE;
    Chiller_Flow_Error := FALSE;
    Motor_Selection_Error := FALSE;
    Insufficient_Motor_Capacity := FALSE;
    Insufficient_Available_Motors := FALSE;
    MCC_Error_Status := FALSE;
    Particle_Contactor_Error := FALSE;
    Circ_Contactor_Error := FALSE;
    Circ_SoftStarter_Error := FALSE;
    CoilTube_Contactor_Error := FALSE;
    CoilTube_SoftStarter_Error := FALSE;
    System_Error_Active := FALSE;
    Total_Active_Errors := 0;
    
    // Legacy compatibility outputs
    Emergency_Stop_Required := FALSE;
    Master_Error_Code := 0;
    Current_Error_Priority := 0;
    
    Analog_Error_Word := 0;
    Current_Analog_Error_Code := 0;
    Current_Dual_Controller_Error_Code := 0;
    Current_Flowmeter_Error_Code := 0;
    Flowmeter_Watchdog_Count := 0;
    Current_G120C_Error_Code := 0;
    Current_G120C_Warning_Code := 0;
    G120C_Fault_Count := 0;
    Current_Valve_Error_Code := 0;
    Valve_Controller_OK := FALSE;
    Current_Filter_Error_Code := 0;
    Total_Filter_Error_Count := 0;
    Current_Motor_Selection_Error_Code := 0;
    Motor_Selection_Error_Count := 0;
    Current_MCC_Error_Code := 0;
    Total_MCC_Error_Count := 0;
    
    Processing_Timer(IN := FALSE, PT := T#100ms);
    
    // Reset DB outputs - error manager specific variables only
    // (Safety/Motor variables handled by FB_Safety_Motor_Error_Processing)
    // (Analog variables handled by FB_Analog_Input_Processing)
    "DB_HGU_Execution_V17".SYSTEM_ERROR_ACTIVE := FALSE;
    "DB_HGU_Execution_V17".DUAL_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOW_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".PRESSURE_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOWMETER_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOWMETER_WATCHDOG_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_MOTOR_FAULT := FALSE;
    "DB_HGU_Execution_V17".G120C_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_SAFETY_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_PARAMETER_ERROR := FALSE;
    "DB_HGU_Execution_V17".VALVE_WATCHDOG_ERROR := FALSE;
    "DB_HGU_Execution_V17".VALVE_EMERGENCY_STOP_REQUIRED := FALSE;
    "DB_HGU_Execution_V17".VALVE_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".DIGITAL_INPUT_ERROR := FALSE;
    "DB_HGU_Execution_V17".FILTER_ERROR := FALSE;
    "DB_HGU_Execution_V17".TANK_LEVEL_ERROR := FALSE;
    "DB_HGU_Execution_V17".CHILLER_FLOW_ERROR := FALSE;
    "DB_HGU_Execution_V17".MOTOR_SELECTION_ERROR := FALSE;
    "DB_HGU_Execution_V17".INSUFFICIENT_MOTOR_CAPACITY := FALSE;
    "DB_HGU_Execution_V17".INSUFFICIENT_AVAILABLE_MOTORS := FALSE;
    "DB_HGU_Execution_V17".MCC_ERROR_STATUS := FALSE;
    "DB_HGU_Execution_V17".PARTICLE_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".CIRC_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".CIRC_SOFTSTARTER_ERROR := FALSE;
    "DB_HGU_Execution_V17".COILTUBE_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".COILTUBE_SOFTSTARTER_ERROR := FALSE;
END_IF;

END_FUNCTION_BLOCK