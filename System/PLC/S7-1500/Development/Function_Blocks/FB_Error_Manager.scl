FUNCTION_BLOCK "FB_Error_Manager"
{ S7_Optimized_Access := 'TRUE' }
VERSION : '1.0'
// =============================================================================
// TUSAŞ HGU System-Wide Error Manager V17
// =============================================================================
// Purpose: Centralized error and warning collection from all Function Blocks
// Features: Priority-based error management, alarm categorization, system status
// 
// ERROR PRIORITY LEVELS:
// ─────────────────────────────────────────────────────────────────────────────
// Priority 0: System OK
// Priority 1: Info/Status (Blue)       - System information, maintenance due
// Priority 2: Warning (Yellow)         - Non-critical warnings, filter alerts
// Priority 3: Error (Orange)           - Operational errors, sensor faults
// Priority 4: Critical (Red)           - Safety critical errors, motor faults
// Priority 5: Emergency (Flashing Red) - Emergency stop required, valve critical
//
// ERROR CATEGORIES & INTEGRATION SOURCES:
// ─────────────────────────────────────────────────────────────────────────────
// A. Safety Critical (Priority 4-5)
//    Source: FB_Safety_Motor_Error_Processing → DB_HGU_Execution_V17
//    - Emergency stops, protection failures, motor thermal faults
//
// B. Sensor Monitoring (Priority 1-3)  
//    Source: FB_Analog_Input_Processing → DB_HGU_Execution_V17
//    - 19 analog sensors (temperature, pressure, level, flow)
//
// C. Control Systems (Priority 2-3)
//    Source: FB_Dual_Controller instances → DB_System_Coordinator_Instance
//    - Flow controller errors (codes 11-14), Pressure controller errors (21-24)
//
// D. Communication (Priority 2-3)
//    Source: FB_Flowmeter_CANOPEN → DB_HGU_Execution_V17 (CAN variables)
//    - CAN communication, device watchdog timeouts
//
// E. Drive Systems (Priority 2-4)  
//    Source: FB_G120C_Drive instances → DB_HGU_Execution_V17 (Motor status variables)
//    - Motor faults, communication errors, safety errors
//
// F. Safety Valves (Priority 4-5)
//    Source: FB_Pressure_Safety_Valves instance → Instance access needed
//    - 250ms watchdog timeout, emergency stop requirements
//
// G. Digital I/O & Filters (Priority 1-2)
//    Source: FB_Digital_Input_Processing instance → Instance access needed  
//    - Filter errors, tank level, chiller flow monitoring
//
// H. Motor Selection (Priority 1-2)
//    Source: FB_Motor_Selection instance → Instance access needed
//    - Capacity errors, insufficient motors available
//
// I. MCC Command-Feedback (Priority 2)
//    Source: FB_Safety_Status_Manager instance → Instance access needed
//    - DO command vs feedback mismatch detection (5 pairs)
// =============================================================================

VAR_INPUT
    Enable : Bool := FALSE;                    // Enable error manager
END_VAR

VAR_OUTPUT
    // ═════════════════════════════════════════════════════════════════════════════
    // SAFETY CRITICAL OUTPUTS (Priority 4-5)
    // ═════════════════════════════════════════════════════════════════════════════
    Emergency_Stop_Active : Bool := FALSE;          // Any emergency stop active
    Motor_Thermal_Error : Bool := FALSE;            // Any motor thermal error
    Valve_Watchdog_Error : Bool := FALSE;           // CRITICAL: 250ms valve watchdog timeout
    Valve_Emergency_Stop_Required : Bool := FALSE;  // CRITICAL: Emergency stop required
    
    // ═════════════════════════════════════════════════════════════════════════════
    // SENSOR MONITORING OUTPUTS (Priority 1-3)
    // ═════════════════════════════════════════════════════════════════════════════
    Analog_Sensor_Error : Bool := FALSE;            // Any analog sensor error active
    Temperature_Sensor_Error : Bool := FALSE;       // Temperature sensors (1, 18, 19)
    Level_Sensor_Error : Bool := FALSE;             // Level sensor (2) - ContinuousLevelSensor
    Aqua_Sensor_Error : Bool := FALSE;              // Aqua sensor (3) - AquaSensor
    Pump_Pressure_Error : Bool := FALSE;            // Pump pressure sensors (4-10)
    HSM_Pressure_Error : Bool := FALSE;             // HSM pressure sensors (11-17)
    
    // ═════════════════════════════════════════════════════════════════════════════
    // CONTROL SYSTEM OUTPUTS (Priority 2-3)
    // ═════════════════════════════════════════════════════════════════════════════
    Dual_Controller_Error : Bool := FALSE;          // Any dual controller error active
    Flow_Controller_Error : Bool := FALSE;          // Flow controller errors (11-14)
    Pressure_Controller_Error : Bool := FALSE;      // Pressure controller errors (21-24)
    
    // ═════════════════════════════════════════════════════════════════════════════
    // COMMUNICATION OUTPUTS (Priority 2-3)
    // ═════════════════════════════════════════════════════════════════════════════
    Flowmeter_Communication_Error : Bool := FALSE;  // Flowmeter communication error active
    Flowmeter_Watchdog_Error : Bool := FALSE;       // Any flowmeter watchdog timeout
    G120C_Communication_Error : Bool := FALSE;      // Any G120C communication error
    Valve_Communication_Error : Bool := FALSE;      // Valve controller communication error
    
    // ═════════════════════════════════════════════════════════════════════════════
    // DRIVE SYSTEM OUTPUTS (Priority 2-4)
    // ═════════════════════════════════════════════════════════════════════════════
    G120C_Motor_Fault : Bool := FALSE;              // Any G120C motor fault active
    G120C_Safety_Error : Bool := FALSE;             // Any G120C safety error
    G120C_Parameter_Error : Bool := FALSE;          // Any G120C parameter error
    
    // ═════════════════════════════════════════════════════════════════════════════
    // FILTER & DIGITAL I/O OUTPUTS (Priority 1-2)
    // ═════════════════════════════════════════════════════════════════════════════
    Digital_Input_Error : Bool := FALSE;            // Any digital input error active
    Filter_Error : Bool := FALSE;                   // Any motor filter error active (1-7)
    Tank_Level_Error : Bool := FALSE;               // Tank level error (low level)
    Chiller_Flow_Error : Bool := FALSE;             // Chiller water flow error
    
    // ═════════════════════════════════════════════════════════════════════════════
    // MOTOR SELECTION OUTPUTS (Priority 1-2)
    // ═════════════════════════════════════════════════════════════════════════════
    Motor_Selection_Error : Bool := FALSE;          // Motor selection algorithm error
    Insufficient_Motor_Capacity : Bool := FALSE;    // Insufficient motor flow capacity
    Insufficient_Available_Motors : Bool := FALSE;  // Not enough motors available
    
    // ═════════════════════════════════════════════════════════════════════════════
    // MCC COMMAND-FEEDBACK OUTPUTS (Priority 2)
    // ═════════════════════════════════════════════════════════════════════════════
    MCC_Error_Status : Bool := FALSE;               // Any MCC command-feedback error active
    Particle_Contactor_Error : Bool := FALSE;       // Particle contactor mismatch error
    Circ_Contactor_Error : Bool := FALSE;           // Circulation contactor mismatch error
    Circ_SoftStarter_Error : Bool := FALSE;         // Circulation soft starter mismatch error
    CoilTube_Contactor_Error : Bool := FALSE;       // CoilTube contactor mismatch error
    CoilTube_SoftStarter_Error : Bool := FALSE;     // CoilTube soft starter mismatch error
    
    // ═════════════════════════════════════════════════════════════════════════════
    // SYSTEM STATUS OUTPUTS
    // ═════════════════════════════════════════════════════════════════════════════
    System_Error_Active : Bool := FALSE;            // Any system error active
    Total_Active_Errors : USInt := 0;               // Total number of active errors
    
    // ═════════════════════════════════════════════════════════════════════════════
    // LEGACY COMPATIBILITY OUTPUTS (for existing code)
    // ═════════════════════════════════════════════════════════════════════════════
    Emergency_Stop_Required : Bool := FALSE;        // Emergency stop required (alias)
    Master_Error_Code : USInt := 0;                 // Master error code (highest priority)
    Current_Error_Priority : USInt := 0;            // Current error priority level (0-5)
END_VAR

VAR
    // ═════════════════════════════════════════════════════════════════════════════
    // ERROR CODE TRACKING VARIABLES (for priority-based master error code)
    // ═════════════════════════════════════════════════════════════════════════════
    Current_Analog_Error_Code : USInt := 0;             // Copy of ANALOG_ERROR_CODE from DB
    Current_Dual_Controller_Error_Code : USInt := 0;    // Current dual controller error code
    Current_Flowmeter_Error_Code : USInt := 0;          // Current flowmeter error code
    Current_G120C_Error_Code : USInt := 0;              // Current G120C error code (highest priority)
    Current_G120C_Warning_Code : USInt := 0;            // Current G120C warning code
    Current_Valve_Error_Code : USInt := 0;              // Current valve controller error code
    Current_Filter_Error_Code : USInt := 0;             // Current filter error code
    Current_Motor_Selection_Error_Code : USInt := 0;    // Current motor selection error code
    Current_MCC_Error_Code : USInt := 0;                // Current MCC error code (1-5)
    
    // ═════════════════════════════════════════════════════════════════════════════
    // ERROR COUNT TRACKING VARIABLES (for statistics and diagnostics)
    // ═════════════════════════════════════════════════════════════════════════════
    Flowmeter_Watchdog_Count : USInt := 0;              // Number of active watchdog errors
    G120C_Fault_Count : USInt := 0;                     // Number of motors in fault
    Total_Filter_Error_Count : USInt := 0;              // Total active filter errors
    Motor_Selection_Error_Count : USInt := 0;           // Number of motor selection errors
    Total_MCC_Error_Count : USInt := 0;                 // Total number of active MCC errors
    
    // ═════════════════════════════════════════════════════════════════════════════
    // STATUS TRACKING VARIABLES (for communication and system status)
    // ═════════════════════════════════════════════════════════════════════════════
    Analog_Error_Word : Word := 0;                      // Copy of ANALOG_ERROR_WORD from DB
    Valve_Controller_OK : Bool := FALSE;                // Valve controller communication status
    
    // ═════════════════════════════════════════════════════════════════════════════
    // PROCESSING CONTROL VARIABLES
    // ═════════════════════════════════════════════════════════════════════════════
    Processing_Timer : TON;                             // 100ms processing cycle timer
    Init_Complete : Bool := FALSE;                      // Initialization complete flag
    i : USInt;                                          // Loop counter for motor checks
END_VAR

VAR_TEMP
    Temp_DWord : DWord;
    Temp_Bool : Bool;
END_VAR

BEGIN

// ═════════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═════════════════════════════════════════════════════════════════════════════
IF NOT Init_Complete THEN
    // Initialize safety critical outputs
    Emergency_Stop_Active := FALSE;
    Motor_Thermal_Error := FALSE;
    Valve_Watchdog_Error := FALSE;
    Valve_Emergency_Stop_Required := FALSE;
    
    // Initialize sensor monitoring outputs
    Analog_Sensor_Error := FALSE;
    Temperature_Sensor_Error := FALSE;
    Level_Sensor_Error := FALSE;
    Aqua_Sensor_Error := FALSE;
    Pump_Pressure_Error := FALSE;
    HSM_Pressure_Error := FALSE;
    
    // Initialize control system outputs
    Dual_Controller_Error := FALSE;
    Flow_Controller_Error := FALSE;
    Pressure_Controller_Error := FALSE;
    
    // Initialize communication outputs
    Flowmeter_Communication_Error := FALSE;
    Flowmeter_Watchdog_Error := FALSE;
    G120C_Communication_Error := FALSE;
    Valve_Communication_Error := FALSE;
    
    // Initialize drive system outputs
    G120C_Motor_Fault := FALSE;
    G120C_Safety_Error := FALSE;
    G120C_Parameter_Error := FALSE;
    
    // Initialize filter & digital I/O outputs
    Digital_Input_Error := FALSE;
    Filter_Error := FALSE;
    Tank_Level_Error := FALSE;
    Chiller_Flow_Error := FALSE;
    
    // Initialize motor selection outputs
    Motor_Selection_Error := FALSE;
    Insufficient_Motor_Capacity := FALSE;
    Insufficient_Available_Motors := FALSE;
    
    // Initialize MCC command-feedback outputs
    MCC_Error_Status := FALSE;
    Particle_Contactor_Error := FALSE;
    Circ_Contactor_Error := FALSE;
    Circ_SoftStarter_Error := FALSE;
    CoilTube_Contactor_Error := FALSE;
    CoilTube_SoftStarter_Error := FALSE;
    
    // Initialize system status outputs
    System_Error_Active := FALSE;
    Total_Active_Errors := 0;
    
    // Initialize legacy compatibility outputs
    Emergency_Stop_Required := FALSE;
    Master_Error_Code := 0;
    Current_Error_Priority := 0;
    
    // Initialize processing timer
    Processing_Timer(IN := FALSE, PT := T#100ms);
    Init_Complete := TRUE;
END_IF;

// ═════════════════════════════════════════════════════════════════════════════
// MAIN PROCESSING LOGIC
// ═════════════════════════════════════════════════════════════════════════════
IF Enable THEN
    
    // Process every 100ms for optimal performance
    Processing_Timer(IN := TRUE, PT := T#100ms);
    
    IF Processing_Timer.Q THEN
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 1: READ SAFETY CRITICAL ERRORS (Priority 4-5)
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Safety_Motor_Error_Processing → DB_HGU_Execution_V17
        Emergency_Stop_Active := "DB_HGU_Execution_V17".CRITICAL_SAFETY_ERROR;
        Motor_Thermal_Error := "DB_HGU_Execution_V17".ANY_MOTOR_ERROR;
        
        // TODO: Valve safety errors (requires FB_Pressure_Safety_Valves instance access)
        // Valve_Watchdog_Error := "Valve_Instance".Watchdog_Error;
        // Valve_Emergency_Stop_Required := "Valve_Instance".Emergency_Stop_Required;
        // Valve_Communication_Error := NOT "Valve_Instance".Communication_OK;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 2: READ SENSOR MONITORING ERRORS (Priority 1-3)
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Analog_Input_Processing → DB_HGU_Execution_V17
        Analog_Sensor_Error := "DB_HGU_Execution_V17".ANALOG_SENSOR_ERROR;
        Current_Analog_Error_Code := "DB_HGU_Execution_V17".ANALOG_ERROR_CODE;
        Analog_Error_Word := "DB_HGU_Execution_V17".ANALOG_ERROR_WORD;
        
        // Categorize analog sensor errors for simplified outputs
        Temperature_Sensor_Error := FALSE;
        Level_Sensor_Error := FALSE;
        Aqua_Sensor_Error := FALSE;
        Pump_Pressure_Error := FALSE;
        HSM_Pressure_Error := FALSE;
        
        IF Analog_Sensor_Error THEN
            CASE Current_Analog_Error_Code OF
                1, 18, 19:                      // Temperature sensors (system, chiller inlet/outlet)
                    Temperature_Sensor_Error := TRUE;
                2:                              // Continuous level sensor
                    Level_Sensor_Error := TRUE;
                3:                              // Aqua sensor
                    Aqua_Sensor_Error := TRUE;
                4, 5, 6, 7, 8, 9, 10:          // Pump pressure sensors (Motors 1-6, CoilTube)
                    Pump_Pressure_Error := TRUE;
                11, 12, 13, 14, 15, 16, 17:    // HSM pressure sensors (1-7)
                    HSM_Pressure_Error := TRUE;
            END_CASE;
        END_IF;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 3: READ CONTROL SYSTEM ERRORS (Priority 2-3)  
        // ─────────────────────────────────────────────────────────────────────────
        // MODULAR ARCHITECTURE UPDATE: Read errors from FB_System_Coordinator_V2
        // Source: FB_System_Coordinator_V2 → Error aggregation outputs
        Dual_Controller_Error := "DB_System_Coordinator_Instance".Dual_Controller_1_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_2_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_3_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_4_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_5_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_6_Error OR
                                 "DB_System_Coordinator_Instance".Dual_Controller_7_Error;
        
        // Get the first active error code (priority by motor number)
        Current_Dual_Controller_Error_Code := 0;
        IF "DB_System_Coordinator_Instance".Dual_Controller_1_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_1_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_2_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_2_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_3_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_3_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_4_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_4_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_5_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_5_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_6_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_6_Error_Code;
        ELSIF "DB_System_Coordinator_Instance".Dual_Controller_7_Error THEN 
            Current_Dual_Controller_Error_Code := "DB_System_Coordinator_Instance".Dual_Controller_7_Error_Code;
        END_IF;
        
        // Categorize dual controller errors (flow = 11-14, pressure = 21-24)
        Flow_Controller_Error := FALSE;
        Pressure_Controller_Error := FALSE;
        
        IF Current_Dual_Controller_Error_Code >= 11 AND Current_Dual_Controller_Error_Code <= 14 THEN
            Flow_Controller_Error := TRUE;
        ELSIF Current_Dual_Controller_Error_Code >= 21 AND Current_Dual_Controller_Error_Code <= 24 THEN
            Pressure_Controller_Error := TRUE;
        END_IF;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 4: READ COMMUNICATION ERRORS (Priority 2-3)
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Flowmeter_CANOPEN → DB_HGU_Execution_V17 (CAN variables)
        Flowmeter_Communication_Error := "DB_HGU_Execution_V17".CAN_SYSTEM_ERROR;
        
        IF Flowmeter_Communication_Error THEN
            Current_Flowmeter_Error_Code := 1;         // Generic CAN communication error
        ELSE
            Current_Flowmeter_Error_Code := 0;         // No error
        END_IF;
        
        // Check CAN device watchdog status (14 devices expected)
        IF NOT "DB_HGU_Execution_V17".CAN_TCP_CONNECTED OR "DB_HGU_Execution_V17".CAN_ACTIVE_DEVICE_COUNT < 14 THEN
            Flowmeter_Watchdog_Error := TRUE;
            Flowmeter_Watchdog_Count := 14 - "DB_HGU_Execution_V17".CAN_ACTIVE_DEVICE_COUNT;
        ELSE
            Flowmeter_Watchdog_Error := FALSE;
            Flowmeter_Watchdog_Count := 0;
        END_IF;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 5: READ DRIVE SYSTEM ERRORS (Priority 2-4)
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_G120C_Drive instances → DB_HGU_Execution_V17 (Motor status variables)
        G120C_Motor_Fault := FALSE;
        G120C_Communication_Error := FALSE;
        G120C_Safety_Error := FALSE;
        G120C_Parameter_Error := FALSE;
        G120C_Fault_Count := 0;
        Current_G120C_Error_Code := 0;
        Current_G120C_Warning_Code := 0;
        
        // Check all 6 motors for fault status (Status 3 = Error)
        FOR i := 1 TO 6 DO
            CASE i OF
                1: IF "DB_HGU_Execution_V17".MOTOR_1_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_1_ERROR_CODE;
                       END_IF;
                   END_IF;
                2: IF "DB_HGU_Execution_V17".MOTOR_2_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_2_ERROR_CODE;
                       END_IF;
                   END_IF;
                3: IF "DB_HGU_Execution_V17".MOTOR_3_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_3_ERROR_CODE;
                       END_IF;
                   END_IF;
                4: IF "DB_HGU_Execution_V17".MOTOR_4_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_4_ERROR_CODE;
                       END_IF;
                   END_IF;
                5: IF "DB_HGU_Execution_V17".MOTOR_5_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_5_ERROR_CODE;
                       END_IF;
                   END_IF;
                6: IF "DB_HGU_Execution_V17".MOTOR_6_STATUS = 3 THEN
                       G120C_Motor_Fault := TRUE;
                       G120C_Fault_Count := G120C_Fault_Count + 1;
                       IF Current_G120C_Error_Code = 0 THEN
                           Current_G120C_Error_Code := "DB_HGU_Execution_V17".MOTOR_6_ERROR_CODE;
                       END_IF;
                   END_IF;
            END_CASE;
        END_FOR;
        
        // TODO: Advanced G120C error detection (requires FB_G120C_Drive instance access)
        // G120C_Communication_Error := "Motor_1_G120C_Instance".Communication_Error OR ... ;
        // G120C_Safety_Error := "Motor_1_G120C_Instance".Safety_Error OR ... ;
        // G120C_Parameter_Error := "Motor_1_G120C_Instance".Parameter_Error OR ... ;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 6: READ SAFETY VALVE ERRORS (Priority 4-5) - TODO: Instance access needed
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Pressure_Safety_Valves instance → Instance access needed
        // TODO: Valve_Watchdog_Error := "Valve_Instance".Watchdog_Error;
        // TODO: Valve_Emergency_Stop_Required := "Valve_Instance".Emergency_Stop_Required;
        // TODO: Valve_Communication_Error := NOT "Valve_Instance".Communication_OK;
        
        // Temporary: Reset valve errors until instance access is available
        Valve_Watchdog_Error := FALSE;
        Valve_Emergency_Stop_Required := FALSE;
        Valve_Communication_Error := FALSE;
        Current_Valve_Error_Code := 0;
        Valve_Controller_OK := TRUE;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 7: READ FILTER & DIGITAL I/O ERRORS (Priority 1-2) - TODO: Instance access needed
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Digital_Input_Processing instance → Instance access needed
        // TODO: Digital_Input_Error := "Digital_Input_Instance".Error_Status;
        // TODO: Current_Filter_Error_Code := "Digital_Input_Instance".Error_Code;
        // TODO: Categorize: Filter_Error (codes 1-7), Tank_Level_Error (10), Chiller_Flow_Error (11)
        
        // Temporary: Reset filter errors until instance access is available
        Digital_Input_Error := FALSE;
        Filter_Error := FALSE;
        Tank_Level_Error := FALSE;
        Chiller_Flow_Error := FALSE;
        Current_Filter_Error_Code := 0;
        Total_Filter_Error_Count := 0;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 8: READ MOTOR SELECTION ERRORS (Priority 1-2) - TODO: Instance access needed
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Motor_Selection instance → Instance access needed
        // TODO: Motor_Selection_Error := "Motor_Selection_Instance".Error_Status;
        // TODO: Categorize: Insufficient_Motor_Capacity (code 1), Insufficient_Available_Motors (code 2)
        
        // Temporary: Reset motor selection errors until instance access is available
        Motor_Selection_Error := FALSE;
        Insufficient_Motor_Capacity := FALSE;
        Insufficient_Available_Motors := FALSE;
        Current_Motor_Selection_Error_Code := 0;
        Motor_Selection_Error_Count := 0;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 9: READ MCC COMMAND-FEEDBACK ERRORS (Priority 2) - TODO: Instance access needed
        // ─────────────────────────────────────────────────────────────────────────
        // Source: FB_Safety_Status_Manager instance → Instance access needed
        // TODO: MCC_Error_Status := "Safety_Status_Manager_Instance".MCC_Error_Status;
        // TODO: Read individual DO-feedback errors: Particle, Circ Contactor/SoftStarter, CoilTube Contactor/SoftStarter
        
        // Temporary: Reset MCC errors until instance access is available
        MCC_Error_Status := FALSE;
        Particle_Contactor_Error := FALSE;
        Circ_Contactor_Error := FALSE;
        Circ_SoftStarter_Error := FALSE;
        CoilTube_Contactor_Error := FALSE;
        CoilTube_SoftStarter_Error := FALSE;
        Current_MCC_Error_Code := 0;
        Total_MCC_Error_Count := 0;
        
        // ─────────────────────────────────────────────────────────────────────────
        // STEP 10: CALCULATE SYSTEM STATUS SUMMARY  
        // ─────────────────────────────────────────────────────────────────────────
        
        // Count total active errors across all categories
        Total_Active_Errors := 0;
        // Safety Critical (Priority 4-5)
        IF Emergency_Stop_Active THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Motor_Thermal_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Watchdog_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Emergency_Stop_Required THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Sensor Monitoring (Priority 1-3)
        IF Temperature_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Level_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Aqua_Sensor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Pump_Pressure_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF HSM_Pressure_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Control Systems (Priority 2-3)
        IF Flow_Controller_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Pressure_Controller_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Communication (Priority 2-3)
        IF Flowmeter_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Flowmeter_Watchdog_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Valve_Communication_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Drive Systems (Priority 2-4)
        IF G120C_Motor_Fault THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Safety_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF G120C_Parameter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Filter & Digital I/O (Priority 1-2)
        IF Filter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Tank_Level_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Chiller_Flow_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // Motor Selection (Priority 1-2)
        IF Motor_Selection_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Insufficient_Motor_Capacity THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Insufficient_Available_Motors THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        // MCC Command-Feedback (Priority 2)
        IF Particle_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Circ_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF Circ_SoftStarter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF CoilTube_Contactor_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        IF CoilTube_SoftStarter_Error THEN Total_Active_Errors := Total_Active_Errors + 1; END_IF;
        
        // Overall system error status
        System_Error_Active := Emergency_Stop_Active OR Motor_Thermal_Error OR Analog_Sensor_Error OR 
                              Dual_Controller_Error OR Flowmeter_Communication_Error OR Flowmeter_Watchdog_Error OR
                              G120C_Motor_Fault OR G120C_Communication_Error OR G120C_Safety_Error OR G120C_Parameter_Error OR
                              Valve_Watchdog_Error OR Valve_Emergency_Stop_Required OR Valve_Communication_Error OR
                              Digital_Input_Error OR Filter_Error OR Tank_Level_Error OR Chiller_Flow_Error OR
                              Motor_Selection_Error OR Insufficient_Motor_Capacity OR Insufficient_Available_Motors OR
                              MCC_Error_Status;
        
        // =============================================================================
        // LEGACY COMPATIBILITY OUTPUTS
        // =============================================================================
        
        // Emergency_Stop_Required is alias for Emergency_Stop_Active
        Emergency_Stop_Required := Emergency_Stop_Active;
        
        // Master_Error_Code: Priority-based error code assignment
        Master_Error_Code := 0;
        Current_Error_Priority := 0;
        
        // Priority 5: Emergency Stop and Valve Critical Errors (Critical)
        IF Emergency_Stop_Active THEN
            Master_Error_Code := 100; // Emergency stop base code
            Current_Error_Priority := 5;
        
        // Priority 5: Valve Controller Critical Errors (Emergency)
        ELSIF Valve_Emergency_Stop_Required OR Valve_Watchdog_Error THEN
            IF Valve_Emergency_Stop_Required THEN
                Master_Error_Code := 600; // Valve emergency stop required base code
            ELSE
                Master_Error_Code := 610 + Current_Valve_Error_Code; // Valve watchdog error base + error code (611-619)
            END_IF;
            Current_Error_Priority := 5;
        
        // Priority 4: Motor Thermal Error (High)
        ELSIF Motor_Thermal_Error THEN
            Master_Error_Code := 200; // Motor thermal base code
            Current_Error_Priority := 4;
        
        // Priority 3: G120C Drive Error (Medium-High)
        ELSIF G120C_Motor_Fault OR G120C_Safety_Error THEN
            IF G120C_Safety_Error THEN
                Master_Error_Code := 500; // G120C safety error base code
            ELSE
                Master_Error_Code := 400 + Current_G120C_Error_Code; // G120C motor fault base + error code (401-499)
            END_IF;
            Current_Error_Priority := 3;
        
        // Priority 3: Dual Controller Error (Medium-High)
        ELSIF Dual_Controller_Error THEN
            Master_Error_Code := Current_Dual_Controller_Error_Code; // Use actual error code (11-14, 21-24)
            Current_Error_Priority := 3;
        
        // Priority 2: G120C Communication/Parameter Error (Medium)
        ELSIF G120C_Communication_Error OR G120C_Parameter_Error THEN
            IF G120C_Parameter_Error THEN
                Master_Error_Code := 550; // G120C parameter error base code
            ELSE
                Master_Error_Code := 520; // G120C communication error base code
            END_IF;
            Current_Error_Priority := 2;
        
        // Priority 2: Valve Communication Error (Medium)
        ELSIF Valve_Communication_Error THEN
            Master_Error_Code := 620 + Current_Valve_Error_Code; // Valve communication error base + error code (621-629)
            Current_Error_Priority := 2;
        
        // Priority 2: Flowmeter Communication Error (Medium)
        ELSIF Flowmeter_Communication_Error OR Flowmeter_Watchdog_Error THEN
            IF Flowmeter_Watchdog_Error THEN
                Master_Error_Code := 300 + Flowmeter_Watchdog_Count; // Watchdog error base + count (301-314)
            ELSE
                Master_Error_Code := 300 + Current_Flowmeter_Error_Code; // Communication error base + error code (301-303)
            END_IF;
            Current_Error_Priority := 2;
        
        // Priority 2: Tank Level Error (Medium)
        ELSIF Tank_Level_Error THEN
            Master_Error_Code := 700; // Tank level error base code
            Current_Error_Priority := 2;
        
        // Priority 2: MCC Command-Feedback Error (Medium)
        ELSIF MCC_Error_Status THEN
            Master_Error_Code := 740 + Current_MCC_Error_Code; // MCC error base + error code (741-745)
            Current_Error_Priority := 2;
        
        // Priority 1: Filter, Chiller, and Motor Selection Error (Low)
        ELSIF Filter_Error OR Chiller_Flow_Error OR Motor_Selection_Error OR Insufficient_Motor_Capacity OR Insufficient_Available_Motors THEN
            IF Filter_Error THEN
                Master_Error_Code := 710 + Current_Filter_Error_Code; // Filter error base + error code (711-717)
            ELSIF Chiller_Flow_Error THEN
                Master_Error_Code := 720; // Chiller flow error base code
            ELSIF Insufficient_Motor_Capacity THEN
                Master_Error_Code := 730; // Insufficient motor capacity error
            ELSIF Insufficient_Available_Motors THEN
                Master_Error_Code := 731; // Insufficient available motors error
            ELSE
                Master_Error_Code := 732 + Current_Motor_Selection_Error_Code; // Motor selection error base + error code (733-739)
            END_IF;
            Current_Error_Priority := 1;
        
        // Priority 1: Analog Sensor Error (Low)
        ELSIF Analog_Sensor_Error THEN
            Master_Error_Code := Current_Analog_Error_Code; // Use actual sensor error code (1-19)
            Current_Error_Priority := 1;
        
        // Priority 0: System OK
        ELSE
            Master_Error_Code := 0;
            Current_Error_Priority := 0;
        END_IF;
        
        // Update DB variables (analog variables are handled by FB_Analog_Input_Processing)
        "DB_HGU_Execution_V17".CRITICAL_SAFETY_ERROR := Emergency_Stop_Active;
        "DB_HGU_Execution_V17".ANY_MOTOR_ERROR := Motor_Thermal_Error;
        "DB_HGU_Execution_V17".SYSTEM_ERROR_ACTIVE := System_Error_Active;
        "DB_HGU_Execution_V17".DUAL_CONTROLLER_ERROR := Dual_Controller_Error;
        "DB_HGU_Execution_V17".FLOW_CONTROLLER_ERROR := Flow_Controller_Error;
        "DB_HGU_Execution_V17".PRESSURE_CONTROLLER_ERROR := Pressure_Controller_Error;
        "DB_HGU_Execution_V17".FLOWMETER_COMMUNICATION_ERROR := Flowmeter_Communication_Error;
        "DB_HGU_Execution_V17".FLOWMETER_WATCHDOG_ERROR := Flowmeter_Watchdog_Error;
        "DB_HGU_Execution_V17".G120C_MOTOR_FAULT := G120C_Motor_Fault;
        "DB_HGU_Execution_V17".G120C_COMMUNICATION_ERROR := G120C_Communication_Error;
        "DB_HGU_Execution_V17".G120C_SAFETY_ERROR := G120C_Safety_Error;
        "DB_HGU_Execution_V17".G120C_PARAMETER_ERROR := G120C_Parameter_Error;
        "DB_HGU_Execution_V17".VALVE_WATCHDOG_ERROR := Valve_Watchdog_Error;
        "DB_HGU_Execution_V17".VALVE_EMERGENCY_STOP_REQUIRED := Valve_Emergency_Stop_Required;
        "DB_HGU_Execution_V17".VALVE_COMMUNICATION_ERROR := Valve_Communication_Error;
        "DB_HGU_Execution_V17".DIGITAL_INPUT_ERROR := Digital_Input_Error;
        "DB_HGU_Execution_V17".FILTER_ERROR := Filter_Error;
        "DB_HGU_Execution_V17".TANK_LEVEL_ERROR := Tank_Level_Error;
        "DB_HGU_Execution_V17".CHILLER_FLOW_ERROR := Chiller_Flow_Error;
        "DB_HGU_Execution_V17".MOTOR_SELECTION_ERROR := Motor_Selection_Error;
        "DB_HGU_Execution_V17".INSUFFICIENT_MOTOR_CAPACITY := Insufficient_Motor_Capacity;
        "DB_HGU_Execution_V17".INSUFFICIENT_AVAILABLE_MOTORS := Insufficient_Available_Motors;
        "DB_HGU_Execution_V17".MCC_ERROR_STATUS := MCC_Error_Status;
        "DB_HGU_Execution_V17".PARTICLE_CONTACTOR_ERROR := Particle_Contactor_Error;
        "DB_HGU_Execution_V17".CIRC_CONTACTOR_ERROR := Circ_Contactor_Error;
        "DB_HGU_Execution_V17".CIRC_SOFTSTARTER_ERROR := Circ_SoftStarter_Error;
        "DB_HGU_Execution_V17".COILTUBE_CONTACTOR_ERROR := CoilTube_Contactor_Error;
        "DB_HGU_Execution_V17".COILTUBE_SOFTSTARTER_ERROR := CoilTube_SoftStarter_Error;
        
        Processing_Timer(IN := FALSE, PT := T#100ms);
    END_IF;
    
ELSE
    // =============================================================================
    // DISABLED STATE
    // =============================================================================
    Emergency_Stop_Active := FALSE;
    Motor_Thermal_Error := FALSE;
    Analog_Sensor_Error := FALSE;
    Temperature_Sensor_Error := FALSE;
    Level_Sensor_Error := FALSE;
    Aqua_Sensor_Error := FALSE;
    Pump_Pressure_Error := FALSE;
    HSM_Pressure_Error := FALSE;
    Dual_Controller_Error := FALSE;
    Flow_Controller_Error := FALSE;
    Pressure_Controller_Error := FALSE;
    Flowmeter_Communication_Error := FALSE;
    Flowmeter_Watchdog_Error := FALSE;
    G120C_Motor_Fault := FALSE;
    G120C_Communication_Error := FALSE;
    G120C_Safety_Error := FALSE;
    G120C_Parameter_Error := FALSE;
    Valve_Watchdog_Error := FALSE;
    Valve_Emergency_Stop_Required := FALSE;
    Valve_Communication_Error := FALSE;
    Digital_Input_Error := FALSE;
    Filter_Error := FALSE;
    Tank_Level_Error := FALSE;
    Chiller_Flow_Error := FALSE;
    Motor_Selection_Error := FALSE;
    Insufficient_Motor_Capacity := FALSE;
    Insufficient_Available_Motors := FALSE;
    MCC_Error_Status := FALSE;
    Particle_Contactor_Error := FALSE;
    Circ_Contactor_Error := FALSE;
    Circ_SoftStarter_Error := FALSE;
    CoilTube_Contactor_Error := FALSE;
    CoilTube_SoftStarter_Error := FALSE;
    System_Error_Active := FALSE;
    Total_Active_Errors := 0;
    
    // Legacy compatibility outputs
    Emergency_Stop_Required := FALSE;
    Master_Error_Code := 0;
    Current_Error_Priority := 0;
    
    Analog_Error_Word := 0;
    Current_Analog_Error_Code := 0;
    Current_Dual_Controller_Error_Code := 0;
    Current_Flowmeter_Error_Code := 0;
    Flowmeter_Watchdog_Count := 0;
    Current_G120C_Error_Code := 0;
    Current_G120C_Warning_Code := 0;
    G120C_Fault_Count := 0;
    Current_Valve_Error_Code := 0;
    Valve_Controller_OK := FALSE;
    Current_Filter_Error_Code := 0;
    Total_Filter_Error_Count := 0;
    Current_Motor_Selection_Error_Code := 0;
    Motor_Selection_Error_Count := 0;
    Current_MCC_Error_Code := 0;
    Total_MCC_Error_Count := 0;
    
    Processing_Timer(IN := FALSE, PT := T#100ms);
    
    // Reset DB outputs - error manager specific variables only
    // (Safety/Motor variables handled by FB_Safety_Motor_Error_Processing)
    // (Analog variables handled by FB_Analog_Input_Processing)
    "DB_HGU_Execution_V17".SYSTEM_ERROR_ACTIVE := FALSE;
    "DB_HGU_Execution_V17".DUAL_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOW_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".PRESSURE_CONTROLLER_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOWMETER_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".FLOWMETER_WATCHDOG_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_MOTOR_FAULT := FALSE;
    "DB_HGU_Execution_V17".G120C_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_SAFETY_ERROR := FALSE;
    "DB_HGU_Execution_V17".G120C_PARAMETER_ERROR := FALSE;
    "DB_HGU_Execution_V17".VALVE_WATCHDOG_ERROR := FALSE;
    "DB_HGU_Execution_V17".VALVE_EMERGENCY_STOP_REQUIRED := FALSE;
    "DB_HGU_Execution_V17".VALVE_COMMUNICATION_ERROR := FALSE;
    "DB_HGU_Execution_V17".DIGITAL_INPUT_ERROR := FALSE;
    "DB_HGU_Execution_V17".FILTER_ERROR := FALSE;
    "DB_HGU_Execution_V17".TANK_LEVEL_ERROR := FALSE;
    "DB_HGU_Execution_V17".CHILLER_FLOW_ERROR := FALSE;
    "DB_HGU_Execution_V17".MOTOR_SELECTION_ERROR := FALSE;
    "DB_HGU_Execution_V17".INSUFFICIENT_MOTOR_CAPACITY := FALSE;
    "DB_HGU_Execution_V17".INSUFFICIENT_AVAILABLE_MOTORS := FALSE;
    "DB_HGU_Execution_V17".MCC_ERROR_STATUS := FALSE;
    "DB_HGU_Execution_V17".PARTICLE_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".CIRC_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".CIRC_SOFTSTARTER_ERROR := FALSE;
    "DB_HGU_Execution_V17".COILTUBE_CONTACTOR_ERROR := FALSE;
    "DB_HGU_Execution_V17".COILTUBE_SOFTSTARTER_ERROR := FALSE;
END_IF;

END_FUNCTION_BLOCK